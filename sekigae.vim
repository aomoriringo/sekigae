scriptencoding utf-8

" Bitwise
function! s:lshift(a, n)
  return  a:a * s:pow2[s:and(a:n, 0x1F)]
endfunction

function! s:rshift(a, n)
  let n = s:and(a:n, 0x1F)
  return n == 0 ? a:a :
  \  a:a < 0 ? (a:a - 0x80000000) / s:pow2[n] + 0x40000000 / s:pow2[n - 1]
  \          : a:a / s:pow2[n]
endfunction

function! s:and(a, b)
  let a = a:a < 0 ? a:a - 0x80000000 : a:a
  let b = a:b < 0 ? a:b - 0x80000000 : a:b
  let r = 0
  let n = 1
  while a && b
    let r += s:and[a % 0x10][b % 0x10] * n
    let a = a / 0x10
    let b = b / 0x10
    let n = n * 0x10
  endwhile
  if (a:a < 0) && (a:b < 0)
    let r += 0x80000000
  endif
  return r
endfunction

function! s:or(a, b)
  let a = a:a < 0 ? a:a - 0x80000000 : a:a
  let b = a:b < 0 ? a:b - 0x80000000 : a:b
  let r = 0
  let n = 1
  while a || b
    let r += s:or[a % 0x10][b % 0x10] * n
    let a = a / 0x10
    let b = b / 0x10
    let n = n * 0x10
  endwhile
  if (a:a < 0) || (a:b < 0)
    let r += 0x80000000
  endif
  return r
endfunction

function! s:xor(a, b)
  let a = a:a < 0 ? a:a - 0x80000000 : a:a
  let b = a:b < 0 ? a:b - 0x80000000 : a:b
  let r = 0
  let n = 1
  while a || b
    let r += s:xor[a % 0x10][b % 0x10] * n
    let a = a / 0x10
    let b = b / 0x10
    let n = n * 0x10
  endwhile
  if (a:a < 0) != (a:b < 0)
    let r += 0x80000000
  endif
  return r
endfunction

let s:pow2 = [
      \ 0x1,        0x2,        0x4,        0x8,
      \ 0x10,       0x20,       0x40,       0x80,
      \ 0x100,      0x200,      0x400,      0x800,
      \ 0x1000,     0x2000,     0x4000,     0x8000,
      \ 0x10000,    0x20000,    0x40000,    0x80000,
      \ 0x100000,   0x200000,   0x400000,   0x800000,
      \ 0x1000000,  0x2000000,  0x4000000,  0x8000000,
      \ 0x10000000, 0x20000000, 0x40000000, 0x80000000,
      \ ]

let s:and = [
      \ [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0],
      \ [0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1],
      \ [0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2],
      \ [0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3],
      \ [0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4],
      \ [0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5],
      \ [0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6],
      \ [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7],
      \ [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8],
      \ [0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9, 0x8, 0x9],
      \ [0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x2, 0x2, 0x8, 0x8, 0xA, 0xA, 0x8, 0x8, 0xA, 0xA],
      \ [0x0, 0x1, 0x2, 0x3, 0x0, 0x1, 0x2, 0x3, 0x8, 0x9, 0xA, 0xB, 0x8, 0x9, 0xA, 0xB],
      \ [0x0, 0x0, 0x0, 0x0, 0x4, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0xC, 0xC, 0xC, 0xC],
      \ [0x0, 0x1, 0x0, 0x1, 0x4, 0x5, 0x4, 0x5, 0x8, 0x9, 0x8, 0x9, 0xC, 0xD, 0xC, 0xD],
      \ [0x0, 0x0, 0x2, 0x2, 0x4, 0x4, 0x6, 0x6, 0x8, 0x8, 0xA, 0xA, 0xC, 0xC, 0xE, 0xE],
      \ [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF]
      \ ]
let s:or = [
      \ [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF],
      \ [0x1, 0x1, 0x3, 0x3, 0x5, 0x5, 0x7, 0x7, 0x9, 0x9, 0xB, 0xB, 0xD, 0xD, 0xF, 0xF],
      \ [0x2, 0x3, 0x2, 0x3, 0x6, 0x7, 0x6, 0x7, 0xA, 0xB, 0xA, 0xB, 0xE, 0xF, 0xE, 0xF],
      \ [0x3, 0x3, 0x3, 0x3, 0x7, 0x7, 0x7, 0x7, 0xB, 0xB, 0xB, 0xB, 0xF, 0xF, 0xF, 0xF],
      \ [0x4, 0x5, 0x6, 0x7, 0x4, 0x5, 0x6, 0x7, 0xC, 0xD, 0xE, 0xF, 0xC, 0xD, 0xE, 0xF],
      \ [0x5, 0x5, 0x7, 0x7, 0x5, 0x5, 0x7, 0x7, 0xD, 0xD, 0xF, 0xF, 0xD, 0xD, 0xF, 0xF],
      \ [0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0x6, 0x7, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF],
      \ [0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF],
      \ [0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF],
      \ [0x9, 0x9, 0xB, 0xB, 0xD, 0xD, 0xF, 0xF, 0x9, 0x9, 0xB, 0xB, 0xD, 0xD, 0xF, 0xF],
      \ [0xA, 0xB, 0xA, 0xB, 0xE, 0xF, 0xE, 0xF, 0xA, 0xB, 0xA, 0xB, 0xE, 0xF, 0xE, 0xF],
      \ [0xB, 0xB, 0xB, 0xB, 0xF, 0xF, 0xF, 0xF, 0xB, 0xB, 0xB, 0xB, 0xF, 0xF, 0xF, 0xF],
      \ [0xC, 0xD, 0xE, 0xF, 0xC, 0xD, 0xE, 0xF, 0xC, 0xD, 0xE, 0xF, 0xC, 0xD, 0xE, 0xF],
      \ [0xD, 0xD, 0xF, 0xF, 0xD, 0xD, 0xF, 0xF, 0xD, 0xD, 0xF, 0xF, 0xD, 0xD, 0xF, 0xF],
      \ [0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF, 0xE, 0xF],
      \ [0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF, 0xF]
      \ ]
let s:xor = [
      \ [0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF],
      \ [0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6, 0x9, 0x8, 0xB, 0xA, 0xD, 0xC, 0xF, 0xE],
      \ [0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5, 0xA, 0xB, 0x8, 0x9, 0xE, 0xF, 0xC, 0xD],
      \ [0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4, 0xB, 0xA, 0x9, 0x8, 0xF, 0xE, 0xD, 0xC],
      \ [0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 0xC, 0xD, 0xE, 0xF, 0x8, 0x9, 0xA, 0xB],
      \ [0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2, 0xD, 0xC, 0xF, 0xE, 0x9, 0x8, 0xB, 0xA],
      \ [0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1, 0xE, 0xF, 0xC, 0xD, 0xA, 0xB, 0x8, 0x9],
      \ [0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8],
      \ [0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7],
      \ [0x9, 0x8, 0xB, 0xA, 0xD, 0xC, 0xF, 0xE, 0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6],
      \ [0xA, 0xB, 0x8, 0x9, 0xE, 0xF, 0xC, 0xD, 0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5],
      \ [0xB, 0xA, 0x9, 0x8, 0xF, 0xE, 0xD, 0xC, 0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4],
      \ [0xC, 0xD, 0xE, 0xF, 0x8, 0x9, 0xA, 0xB, 0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3],
      \ [0xD, 0xC, 0xF, 0xE, 0x9, 0x8, 0xB, 0xA, 0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2],
      \ [0xE, 0xF, 0xC, 0xD, 0xA, 0xB, 0x8, 0x9, 0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1],
      \ [0xF, 0xE, 0xD, 0xC, 0xB, 0xA, 0x9, 0x8, 0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0]
      \ ]


" Random.Mt19937ar
let s:Generator = {}

function s:Generator.seed(seeds)
  let self._N = 624
  let self._M = 397
  let self._MATRIX_A = 0x9908b0df
  let self._UPPER_MASK = 0x80000000
  let self._LOWER_MASK = 0x7fffffff

  let self._mt = repeat([0], self._N)
  let self._mti = self._N + 1
  call s:_init_by_array(self, a:seeds)
endfunction

function! s:Generator.min()
  return 0x80000000
endfunction

function! s:Generator.max()
  return 0x7FFFFFFF
endfunction

function! s:_init_genrand(g, s)
  let a:g._mt[0] = a:s
  let a:g._mti = 1
  while a:g._mti < a:g._N
    let a:g._mt[a:g._mti] = 1812433253 * s:xor(a:g._mt[a:g._mti-1], s:rshift(a:g._mt[a:g._mti-1], 30)) + a:g._mti
    let a:g._mti += 1
  endwhile
endfunction

function! s:_init_by_array(g, init_key)
  let key_length = len(a:init_key)
  call s:_init_genrand(a:g, 19650218)
  let i = 1
  let j = 0
  let k = a:g._N > key_length ? a:g._N : key_length
  while k
    let a:g._mt[i] = s:xor(a:g._mt[i], s:xor(a:g._mt[i-1], s:rshift(a:g._mt[i-1], 30)) * 1664525) + a:init_key[j] + j
    let i += 1
    let j += 1
    if i >= a:g._N
      let a:g._mt[0] = a:g._mt[a:g._N-1]
      let i = 1
    endif
    if j >= key_length
      let j = 0
    endif
    let k -= 1
  endwhile
  let k = a:g._N - 1
  while k
    let a:g._mt[i] = s:xor(a:g._mt[i], s:xor(a:g._mt[i-1], s:rshift(a:g._mt[i-1], 30)) * 1566083941) - i
    let i += 1
    if i >= a:g._N
      let a:g._mt[0] = a:g._mt[a:g._N-1]
      let i = 1
    endif
    let k -= 1
  endwhile

  let a:g._mt[0] = 0x80000000
endfunction

function! s:Generator.next()
  let mag01 = [0, self._MATRIX_A]

  if self._mti >= self._N
    if self._mti == self._N + 1
      call self._init_genrand(self, 5489)
    endif

    let kk = 0
    while kk < self._N - self._M
      let y = s:or(s:and(self._mt[kk], self._UPPER_MASK), s:and(self._mt[kk+1], self._LOWER_MASK))
      let self._mt[kk] = s:xor(s:xor(self._mt[kk+self._M], s:rshift(y, 1)), mag01[y % 2])
      let kk += 1
    endwhile
    while kk < self._N - 1
      let y = s:or(s:and(self._mt[kk], self._UPPER_MASK), s:and(self._mt[kk+1], self._LOWER_MASK))
      let self._mt[kk] = s:xor(s:xor(self._mt[kk+(self._M-self._N)], s:rshift(y, 1)), mag01[y % 2])
      let kk += 1
    endwhile
    let y = s:or(s:and(self._mt[self._N-1], self._UPPER_MASK), s:and(self._mt[0], self._LOWER_MASK))
    let self._mt[self._N-1] = s:xor(s:xor(self._mt[self._M-1], s:rshift(y, 1)), mag01[y % 2])

    let self._mti = 0
  endif

  let y = self._mt[self._mti]
  let self._mti += 1

  let y = s:xor(y, s:rshift(y, 11))
  let y = s:xor(y, s:and(s:lshift(y, 7), 0x9d2c5680))
  let y = s:xor(y, s:and(s:lshift(y, 15), 0xefc60000))
  let y = s:xor(y, s:rshift(y, 18))

  return y
endfunction

function! s:new_generator()
  let gen = deepcopy(s:Generator)
  call gen.seed([0x123, 0x234, 0x345, 0x456])
  return gen
endfunction

" Random
let s:Random = {}

function! s:Random.next(...)
  if a:0
    return map(range(a:1), 'self._generator.next()')
  endif
  return self._generator.next()
endfunction

function! s:Random.seed(seed)
  let seed = type(a:seed) == type([]) ? a:seed : [a:seed]
  return self._generator.seed(seed)
endfunction

function! s:Random.generate_canonical()
  let b = 32
  let min = self._generator.min() + 0.0
  let r = (self._generator.max() + 0.0) - min + 1.0
  let log2r = float2nr(log(r) / log(2.0))
  let k = max([1, (b + log2r - 1) / log2r])
  let sum = 0.0
  let tmp = 1.0
  while k != 0
    let sum += (self._generator.next() - min) * tmp
    let tmp = tmp * r
    let k -= 1
  endwhile
  return sum / tmp
endfunction

function! s:Random.range(from, ...)
  let [from, to] = a:0 ? [a:from, a:1] : [0, a:from]
  let range = to - from
  let base = self.generate_canonical() * range
  return (type(range) == type(0.0) ? base : float2nr(base)) + from
endfunction

function! s:Random.shuffle(list)
  let pos = len(a:list)
  while 1 < pos
    let n = self.range(pos)
    let pos -= 1
    if n != pos
      let temp = a:list[n]
      let a:list[n] = a:list[pos]
      let a:list[pos] = temp
    endif
  endwhile
  return a:list
endfunction

function! s:make_seed()
  let seed = localtime()
  if has('reltime')
    let time = split(reltimestr(reltime()), '\.')
    for n in time
      let seed = s:xor(seed, str2nr(n))
    endfor
  endif
  if exists('*getpid')
    let seed = s:xor(seed, getpid())
  endif
  return seed
endfunction

function! s:new_random()
  let random = deepcopy(s:Random)
  let random._generator = deepcopy(s:Generator)
  call random.seed(s:make_seed())
  return random
endfunction

let s:rand = s:new_random()

" sekigae
echo s:rand.shuffle(['たけお', 'きたけー', 'ぐっさん', 'おっくん'])
